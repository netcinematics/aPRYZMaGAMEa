# INSTRUCTIONZ for _aWORDZa_

Artificial Intelligence, Natural Language Processing, Tokenizer.

Full-featured, lexical token engine.

---

## OVERVIEW

The following guide gives instructions on how to write _aBetterWordza_.

Including, a THESIS and CONCLUSIONS for Computer Science RESEARCH.


---

### BACKSTORY

In 2003, upon finishing a graduate project on ai, the following breakthrough was realized.

> Artificial intelligence, will remain artificial, as long as our language remains vague.

The breakthrough insight, occured while studying SOCIAL_PHRASES. Which are the most commonly used phrases, that circlate through society. More broad than an Idiom or Quiloquialism. 

~~~

A current example of SOCIAL_PHRASE, popular in common_language today is: "Absolutely, one-hundred-percent".

~~~

### EXACTNESS_in_LANGUAGE

It was from that deep_study of social_phrases that it was realized:

> a computer could never tell exactly if "red herring", meant a fish or a distraction.

The CONTEXT of the most advanced ai engine, must account for all-word-ambiguity. Representing a limit to effectiveness, as cause unavoidable "glitch", exactly where the words are vague.

> A "hallucination" in ai software, must occur exactly where actual confusions exist - in our language. SIG_ENZO_~:)

With that TECHNICAL PROBLEM being realized, an intrepid research project began to SEEK_OUT_BETTER_WORDZ. It was the PROCESS of aBETTERaWORDZa, and the PRACTICE of aWORDZa was born as early as YMD_2003_1_1. 

### HISTORY of RESEARCH

In between professional architect roles, at the highest level, this software was advanced in isolation.

It started as a SONG-LYRIC-RHYMING-ENGINE, but with the realization of a need_for_exactness, and need_for_self_expressiveness. Many more uncommon_revelations continued into a_cascade_of_insights. 


#### endless_examples: 

1. Enhanced_english_evolved. Current_English appears to be highly-diluted in meaning, and we will need ai to train on a more exact language than a_common_english - so an elegant solution of enhanced_english evolved.

2. It had to be a programmer. Observing all human work across all time, compared to current software programmers, anyone_can_see, that software-programming required an exactness - unlike any before in human history. Because, code must be of exact words, or it will not work - every time. Think about it. Software code forces a language exactness, easily avoided, except for a few professions. However, with software code syntax - it continues to become more exact (rapidly) over time. So, at some point:

> It had to be a programmer to add exactness back to the common_english_language, as enhanced_english. Because code fails, or "hallucinates" on every disactual definition.

For the programmer, it is common_actz of work, to define complex instructions exactly. Who else does that? 

> When "naming-convention" borrowed from Computer Science, was reformatted to apply to common_english, anyone_can_see highly unexpected results.

3. It had to be simple. Brevity was very important. Along with self-expressivenes, and a dozen other SYNTAX-DESIGN-PRINCIPLES, were established. Borrowing from COMPUTER SCIENCE naming conventions concepts.

- brevity
- self-descriptiveness
- exactness
- memorable
- conjugative
- combinitive
- readability

Such principles, applied to common_english, appears to "result in more than the sum of its parts".

4. Natural_Limits_of_Language.

It was staggering to realize, the limits_of_common_english, while working on RHYMING_SONG_LYRICS - to conjugate english. From that technical perspective, common_english is quite fragile in its ability to use words across CONTEXT - without being a_disjunctive. In that view, common_english appears to be quite CONTEXT_STATIC. Meaning that a SOCIAL_PHRASE used in one tense, possessive, or expression - often becomes absurd, when transferred to any other CONTEXT. Also an excellent root for humor.

~~~

An excellent example

> ai hallucinations will occur around the same concept dimensions a human humor. Exactly because the ambiquity inherent in laughable puns in SOCIAL_PHRASES. 

~~~


But that isn't all of it. Exactly opposite in fact. It was like a `pull_on_a_thread` where more and more Actual_reality unspooled in cascade_of_insight. While looking at the actual_limits_of_english_language, technically, it was revealed to functionally shatter_like_glass.

> wouldn't it be nice to have a language that doesnt trip all over itself, but combines fluidly - for more expressive common expression?

5. a_CONJUGATIVE_WORDZ

From a technical perspective, the syntax of common_english, was called En_Conjugative or Dis_Conjugative. Meaning: the phrases either are reusable in good grammer, or are limited, and cannot be used in that context. From ai perspective, `is a major drag` on exactness.

> common_english needs to be more exact and more expressive across many contexts.

As seen in the next description.

6. a_COMBINITIVE_WORDZ

As a software programmer, we combine words to create variable names, many times per day.
A naming-convention called "camel-case", helped us do that. Another was the use of UNDERSCORE.

~~~

Basically, it is helpful to humanity, to combineWordsTogether - to express actual_extra_articulate_conceptz.

~~~

> the surprise breakthrough was how well combining words, helps to articulate concepts_yet_expressed. Thoughts_never_thought_before.

After applying this (simple) naming-convention to common_english, the result was immediate and powerful, like a_cascade_of_actual_extra_insight in a blizzard of wavez, of actual_blinding_confuzion. The following describes aExactlyWhy.

> For every actual_limit_in_language, an exact_opposite also exists - to create an actual_extra_ability_of_language. 

So through_the_inversion, technically - language_massively_enhanced, language_vastly_enhanced.

> aWORDZa benefits massively across common_english and vastly in depth_of_articulation potential.

This was especially prevalent, in review of how combined_words_articulate_new_concepts. They were INDEXED into an Ontology, with Taxonomy, unlike ever before - exactly because of naming-conventions borrowed from Computer Science best practices - now applied to common_english.

> We can use language, to much greater effect, with very small syntax adjustments.

> a_vast_and_massive_expressiveness_awaits_us

Observed, after simple_syntax_enhancments of: 

1. UNIVERSAL_UNDERSCORE and 
2. little_a (camelcase)

As common_english_modifiers of maximum effectiveness.

7.  Example of exact_opposite_inverzion_effect

> By looking at something actually_broken, a mind can imagine an exact_opposite - repaired to maximum effect. The_exact_opposite_inverzion_effect. 

~~~

For example, converting each of the following: 

- actual_disconjuctive_wordz to actual_conjuctive_wordz

- actual_amiguity to actual_articulation

- actual_confuzion to actual_clarity

~~~

And there was far more after that, like_a_myriad_of_ocean_wavez, or a_cascade_of_conceptz.


7. a_cascade_of_conceptz

Many functional aspects of common_english, were observed to be limited. As if each were a single snowflake, in all daily communications. That is the blizzard_of_mind, that results - when all_actual_flaws_of_language can_be_seen. 


ExactlyWhere, all were INVERTED_to_EXACT_OPPOSITE_effect. And literally, dozens to hundreds, and thousands - of new language system, now runs dynamically, as it forms spontaneously forever. With exactness, self-discriptiveness, conjugative, and combinitive ability. A simple SYSTEM and PROCESS of (precise) naming-conventions, gradually churn through Actual_Reality - as conzepts, spark_viewz_into_wordz, in_light_of_clarity - of what is actually_real. 


8. where intelligence is artificial no more

It happens in us! In common_english_enhanced. We train the ai with better words, and then the ai trains us for actual_extra_intelligence. As multiple reflecionz of actual_reality.




## CONCLUSION

The tokenizer is less than 1000 line of code. It is a series of loops searching for exactness.

Those tokenz, are then programatically contextualized, and utilized in many advancements.

All of this as a solution to apply CONTEXT while RHYMING_SONG_LYRICS.